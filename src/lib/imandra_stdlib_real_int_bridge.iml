(* The `floor' of a real number, and its use in proving termination
   of functions doing recursion over reals, in answer to a question
   of Remi Desmartin.

   G.Passmore, Imandra
*)

(* Floor by `counting up.'

   Note that this is a function designed principally for reasoning, rather
   than efficient computation! However, a `bridge' of this form is really
   necessary to connect the (continuous) world of reals to the discrete world of
   ints, with a suitable induction principle.
*)

let rec floor_psd_counting (x : real) (base : int) : int =
  if Real.(x <= 0.0) then
    0
  else (
    let base_r = Real.of_int base in
    if base_r = x then
      base
    else if Real.(base_r > x) then
      base - 1
    else
      floor_psd_counting x (base + 1)
  )
  [@@measure Ordinal.of_int (Real.to_int x - base)]

let floor_psd_builtin (x:real) (base : int) : int =
  if Real.(x < 0.) then 0 else Real.to_int x

(* The builtin version of floor trivially satisfies all the theorems,
   but the induction/waterfall fail on the counting version. *)
let floor x b = floor_psd_builtin x b

(* Real->Int conversion for `psd' (i.e., >=0) reals *)

let int_of_real_psd (x : real) : int = floor x 0

theorem thm_floor_psd (x:real) (y: int) = floor x y >= 0
  [@@by auto] [@@rw] [@@fc]

theorem thm_floor_mono_low (x:real) (y:real)  =
  Real.(x <= y) ==> Real.to_int x <= Real.to_int y [@@fc] [@@rw]

(* instance (fun (x:real) -> Real.(x > 0.) && floor x 0 <> Real.to_int x);; *)

theorem thm_floor_eq (x:real) (b:int) =
  (Real.(x >= 0.) && b = 0) ==> floor x b = Real.to_int x
  (* [@@by induct ~on_fun:"floor" ()] *)

(* eval(floor Real.(1./2.) 1);
eval(floor Real.(3./2.) 1); *)

(* instance (fun (x:real) (b:int) -> x = Real.(1./2.) && b = 0 && floor x b <> 0);;
instance (fun (x:real) (b:int) -> x = 1. && b = 0 && floor x b <> 1);; *)

theorem thm_floor_mono (x:real) (y:real) (b:int) =
  Real.(x <= y && x >= 0. && y >= 0.) ==> floor x b <= floor y b
  [@@by auto] [@@rw] [@@fc]

theorem thm_int_of_real_psd_psd x = int_of_real_psd x >= 0
  [@@by auto] [@@rw] [@@fc]

theorem thm_int_of_real_psd_mono x y =
  Real.(x <= y && x >= 0. && y >= 0.)
  ==> (int_of_real_psd x <= int_of_real_psd y) [@trigger]
  [@@by auto] [@@by using (quote_term (thm_floor_mono x y 0))] [@@rw] [@@fc]

theorem thm_inc_by_one_bigger_floor x b =
  Real.(x >= 0. && Real.of_int b <= x) ==> floor Real.(x + 1.0) b > floor x b
  [@@by auto] [@@rw] [@@fc]

theorem thm_inc_by_one_bigger_conv x =
  Real.(x >= 0.)
  ==> int_of_real_psd Real.(x + 1.0)
  > (int_of_real_psd x [@trigger])
  [@@by using (quote_term (thm_inc_by_one_bigger_floor x 0))] [@@by auto] [@@fc]

[@@@disable int_of_real_psd]

(* Ex. we can use this to admit functions recursing on reals!
   Note we add the explicit additional termination condition of
   `(i < 0. || j < 0.)' as we want to keep everything PSD. *)

let rec example (i:real) (j:real) =
   let open Real in
   let dec i j =
     if j <= 0. then (i-1.,j) else (i,j-1.)
   in
   if (i <= 0. && j <= 0.) || (i < 0. || j < 0.) then (
     1.
   ) else (
     let i', j' = dec i j in
     example i' j'
   )
 [@@measure
   Ordinal.pair
     (Ordinal.of_int (int_of_real_psd i))
     (Ordinal.of_int (int_of_real_psd j))]
 [@@by auto]
