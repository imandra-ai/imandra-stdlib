[@@@program]
(* A user-land wrapper around `Verify.top` which uses codegen
   and evaluation to `specialize' a polymorphic goal's type
   parameters to `int`, if there are any.

   G.Passmore, Imandra
*)

let rec spec_on_int (ty : Type.t) : Type.t =
  let f = spec_on_int in
  match Type.view ty with
  | Var _ -> Type.int
  | Arrow (lbl, a, b) -> Type.mk_arrow ~lbl (f a) (f b)
  | Tuple l -> Type.mk_tuple (List.map f l)
  | Constr (c, l) -> Type.mk_constr c (List.map f l)

(* The trick:

   Given a polymorphic

    `f : 'a t`,

   we can define a new function `specd_f` which implicitly
   specializes f through a type annotation and an equality with `f`,
   i.e.,

    `let specd_f : int t = f`.

   That's really all there is to it!
*)

let mk_specd_call db (f_name : string) =
  let d = Event.get_fun_def_by_name db f_name in
  let ty = d.f_ty in
  if Type.is_poly ty then (
    let ty_i = spec_on_int ty in
    let specd_name = Printf.sprintf "%s_specd" f_name in
    let ty_i_str = Type.to_string_as_ocaml ty_i in
    (* probably want to do `eval_logic` here if you have it... *)
    let b =
      Printf.sprintf {| let %s : %s = %s [@@logic] |} specd_name ty_i_str f_name
    in
    Some (specd_name, b)
  ) else
    None

let top db f_name =
  match mk_specd_call db f_name with
  | None -> Verify.top f_name
  | Some (nm, b) ->
    ignore (Imandra.eval_string b);
    Verify.top nm
